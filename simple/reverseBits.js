/**
 * 190. 颠倒二进制位
 * 颠倒给定的 32 位无符号整数的二进制位。

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/reverse-bits
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

示例 1：

输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
 */
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
// 补齐32位二进制，然后整体反转转换
var reverseBits = function (n) {
  let bin = n.toString(2);
  let length = bin.length;
  // 补齐32位长度
  for (let i = 0; i < 32 - length; i++) {
    bin = "0" + bin;
  }
  let result = bin.split("").reverse().join("");
  return parseInt(result, 2);
};

var reverseBits = function (n) {
  let mask = 1; // 使用一个遮罩，每次判断二进制中的一位是0还是1，将其赋值给result
  let result = 0; // 存储结果

  // 以此对比32位二进制数
  for (let i = 0; i < 32; i++) {
    // 每次将结果左移一位，将当前数字填入空位
    // 如果将移动放在if语句之后，会导致多移动一位
    result <<= 1;

    // 判断当前位置是0还是1
    if (n & mask) {
      // 如果是1，才需要填入1
      // 如果是0，无需填入，当前位置左移后自然是0
      result += 1;
    }

    // 将遮罩左移一位，判断下一个位置
    mask <<= 1;
  }
  return result >>> 0;
};
